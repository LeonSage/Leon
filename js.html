<!DOCTYPE>
<html>
<head>
	<title>Equal Height</title>
	<meta  http-equiv="Content-Type" content="text/html;charset=utf-8">
	<style type="text/css">
		body,div,iframe,ul,li{margin: 0px;padding: 0px;}
		.item{width: 90%;margin: 20px auto;border:2px dotted #CCC;}
		em{color: white;font-size: 20px;font-weight: bold;background-color: rgb(43,102,149);display: block;padding: 5px;border-radius: 5px;}
		p,pre{font-size: 15px;font-weight: bold;}
		p{text-indent: 2em;}
	</style>
</head>
<body>
	<div class="item">
		<em>对象的copy</em>
		<p>就是把对象的属性遍历一遍，赋给一个新的对象。</p>
		<pre>
		var deepCopy= function(source) { 
			var result={};
			for (var key in source) {
	      		result[key] = typeof source[key]===’object’? deepCoyp(source[key]): source[key];
	   		} 
	   		return result; 
		}
		</pre>
	</div>
	<div class="item">
		<em>数组的copy(深拷贝/浅拷贝）</em>
		<pre>
		数组直接相等操作实际上只是备份，修改会影响到原数组。
		而实际的copy需要用到arrayObject.slice（start，【end】）
		slice 方法一直复制到 end 所指定的元素，但是不包括该元素。
		如果 start 为负，将它作为 length + start处理，此处 length 为数组的长度。
		如果 end 为负，就将它作为 length + end 处理，此处 length 为数组的长度。
		如果省略 end ，那么 slice 方法将一直复制到 arrayObj 的结尾。如果 end 出现在 start 之前，不复制任何元素到新数组中。
		</pre>
	</div>
	<div class="item">
		<em>用DOM操作动态添加元素</em>
		<p>主要用到document.createElement('obj')和oDiv.appendChild('obj')两个方法来完成</p>
	</div>
	<div class="item">
		<em>图片加载</em>
		<p>页面开始形成dom根据dom与css形成渲染树，这个过程结束后才会加载图片。</p>
	</div>
	<div class="item">
		<em>td顺序颠倒</em>
		<p>使用DOM获取td列表，不断将其添加到tr末尾。</p>
	</div>
	<div class="item">
		<em>实现hashTable</em>
		<p>var hashTable=function(){this.data={};};</p>
		<p>然后依次实现它的add（）、remove（）、contains（）、【length】方法和属性，就完成了哈希表的实现。</p>
	</div>
	<div class="item">
		<em>使用Ajax解析XML</em>
		<pre>
			var xmlHttp=new ActiveXObject("Msxml2.XMLHTTP");   
        	xmlHttp.open("GET", "AJAX", true); 
        	xmlHttp.onreadystatechange=function() {   
                 if (xmlHttp.readyState==4 && xmlHttp.status==200) {   
                    //ajax的XML传输的解析。获取解析的数据   
                     var xml = xmlHttp.responseXML;                       
                     //解析标签<stusn>   
                     //var root1=root.getElementsByTagName("stusn");   
                     //解析<stusn>的第一个标签的nation属性   
                     //var name = root1[0].getAttribute("nation");   
                     var div1 = document.getElementById("ccc");   
                     var stus = xml.getElementsByTagName("stu");   
                     for(var i = 0 ; i < stus.length ; i++){   
                         var dl = document.createElement("dl");   
                         var dt = document.createElement("dt");   
                         var dd = document.createElement("dd");   
                         div1.insertBefore(dl,div1.firstChild);   
                         dl.appendChild(dt);   
                         dl.appendChild(dd);   
                         dt.innerHTML = "姓名:" + stus[i].getElementsByTagName("name")[0].firstChild.data;   
                         dd.innerHTML = "年龄:" + stus[i].getElementsByTagName("age")[0].firstChild.data;   
                     }   
                 }   
      		xmlHttp.send(); 
		</pre>
	</div>
	<div class="item">
		<em>javascript的面向对象</em>
		<p>js面向对象的语言，也有class保留字，但是只是象征意义的。对js的对象封装然后new后会发现属性并不是私有的，隐藏私有变量可以使用getName（）函数来获取内部值。真正的面向对象的继承，封装，多态需要使用原型链和构造函数。</p>
	</div>
	<div class="item">
		<em>原型链与构造函数</em>
		<p>每个对象都有自己的prototype（原型）和constructor（构造函数），prototype默认指向自身的构造函数，将对象A的prototype等于对象B的constructor，则对象A继承于B，形成原型链。如果查找A的属性或对象，则不断向上寻找，直到object对象。其中有isPrototypeOf()方法用来检验一个对象是否属于原型链中，hasPrototypeOf()方法用来检验对象是否属于本地，即不是继承于原型链。</p>
	</div>
	<div class="item">
		<em>闭包</em>
		<pre>
	闭包指有权访问另一个函数作用域中的变量的函数。
	当函数被调用时会创建一个执行环境和相应的作用域链，作用域链本质上是一个指向变量对象的指针列表，活动对象有层次性。
	闭包会使另一个函数的活动对象添加到它的作用域链中，当外部函数返回后，其执行环境的作用域链被销毁，但其活动对象依然被保存在内存中。
	直到匿名函数被销毁，闭包包含的对象才会被销毁，即将其设置为null。
	由于闭包会携带包含他的函数的作用域，因此会占用更多的内存，慎重使用闭包。
		</pre>
	</div>
	<div class="item">
		<em>setTimeout（）的作用域链</em>
		<p>在使用定时器时会将作用域链抛往window对象，所以执行的函数和属性为window下的对象。解决方案为使用that=this，并使用that.prototype；或者with（）添加作用域；或者使用callee（）方法添加作用域。</p>
	</div>
	<div class="item">
		<em>事件处理程序</em>
		<p>DOM2级事件规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。DOM2规定捕获阶段不涉及事件目标，但高版本浏览器都会在捕获阶段触发事件，所以有两次机会操作事件。其中有addEventListener()和removeEventListener(),都接受三个参数：事件名、事件处理程序、布尔值（true表示捕获阶段处理，false是冒泡阶段，一般为了兼容性，均设为false）。添加的事件只能通过这个移除，匿名函数无法移除。IE版为attachEvent()和detachEvent().</p>
	</div>
	<div class="item">
		<em>未完</em>
		<pre>
8、JS如何实现面向对象和继承机制？
9、JS模块的封装方法，比如怎样实现私有变量，不能直接赋值，只能通过公有方法；
10、对闭包的理解，闭包的好处和坏处？
11、对this指针的理解，可以列举几种使用情况？
12、对JS中函数绑定的理解？函数绑定可以使用哪两个函数？
13、jQuery的特点？
14、简述Ajax的异步机制。Ajax有哪些好处和弊端？		
		</pre>
	</div>
</body>
</html>