<!DOCTYPE>
<html>
<head>
	<title>Equal Height</title>
	<meta  http-equiv="Content-Type" content="text/html;charset=utf-8">
	<style type="text/css">
		body,div,iframe,ul,li{margin: 0px;padding: 0px;}
		.item{width: 90%;margin: 20px auto;border:2px dotted #CCC;}
		em{color: white;font-size: 20px;font-weight: bold;background-color: rgb(43,102,149);display: block;padding: 5px;border-radius: 5px;}
		p,pre{font-size: 15px;font-weight: bold;}
		p{text-indent: 2em;}
		.tableCSS{border: 1px solid gray;}
		.tableCSS td{border: 1px dotted gray;}
		article{display: none;}
	</style>
</head>
<body>
	<div class="item">
		<em>对象的copy</em>
		<article>
			<p>就是把对象的属性遍历一遍，赋给一个新的对象。</p>
			<pre>
			var deepCopy= function(source) { 
				var result={};
				for (var key in source) {
		      		result[key] = typeof source[key]===’object’? deepCoyp(source[key]): source[key];
		   		} 
		   		return result; 
			}
			</pre>
		</article>
		
	</div>
	<div class="item">
		<em>数组的copy(深拷贝/浅拷贝）</em>
		<article>
			<pre>
	数组直接相等操作实际上只是备份，修改会影响到原数组。
	而实际的copy需要用到arrayObject.slice（start，【end】）
	slice 方法一直复制到 end 所指定的元素，但是不包括该元素。
	如果 start 为负，将它作为 length + start处理，此处 length 为数组的长度。
	如果 end 为负，就将它作为 length + end 处理，此处 length 为数组的长度。
	如果省略 end ，那么 slice 方法将一直复制到 arrayObj 的结尾。如果 end 出现在 start 之前，不复制任何元素到新数组中。
			</pre>
		</article>
		
	</div>
	<div class="item">
		<em>用DOM操作动态添加元素</em>
		<p>主要用到document.createElement('obj')和oDiv.appendChild('obj')两个方法来完成</p>
	</div>
	<div class="item">
		<em>图片加载</em>
		<p>页面开始形成dom根据dom与css形成渲染树，这个过程结束后才会加载图片。</p>
	</div>
	<div class="item">
		<em>td顺序颠倒</em>
		<p>使用DOM获取td列表，不断将其添加到tr末尾。</p>
	</div>
	<div class="item">
		<em>实现hashTable</em>
		<p>var hashTable=function(){this.data={};};</p>
		<p>然后依次实现它的add（）、remove（）、contains（）、【length】方法和属性，就完成了哈希表的实现。</p>
	</div>
	<div class="item">
		<em>使用Ajax解析XML</em>
		<pre>
			var xmlHttp=new ActiveXObject("Msxml2.XMLHTTP");   
        	xmlHttp.open("GET", "AJAX", true); 
        	xmlHttp.onreadystatechange=function() {   
                 if (xmlHttp.readyState==4 && xmlHttp.status==200) {   
                    //ajax的XML传输的解析。获取解析的数据   
                     var xml = xmlHttp.responseXML;                       
                     //解析标签<stusn>   
                     //var root1=root.getElementsByTagName("stusn");   
                     //解析<stusn>的第一个标签的nation属性   
                     //var name = root1[0].getAttribute("nation");   
                     var div1 = document.getElementById("ccc");   
                     var stus = xml.getElementsByTagName("stu");   
                     for(var i = 0 ; i < stus.length ; i++){   
                         var dl = document.createElement("dl");   
                         var dt = document.createElement("dt");   
                         var dd = document.createElement("dd");   
                         div1.insertBefore(dl,div1.firstChild);   
                         dl.appendChild(dt);   
                         dl.appendChild(dd);   
                         dt.innerHTML = "姓名:" + stus[i].getElementsByTagName("name")[0].firstChild.data;   
                         dd.innerHTML = "年龄:" + stus[i].getElementsByTagName("age")[0].firstChild.data;   
                     }   
                 }   
      		xmlHttp.send(); 
		</pre>
	</div>
	<div class="item">
		<em>javascript的面向对象</em>
		<p>js面向对象的语言，也有class保留字，但是只是象征意义的。对js的对象封装然后new后会发现属性并不是私有的，隐藏私有变量可以使用getName（）函数来获取内部值。真正的面向对象的继承，封装，多态需要使用原型链和构造函数。</p>
	</div>
	<div class="item">
		<em>原型链与构造函数</em>
		<p>每个对象都有自己的prototype（原型）和constructor（构造函数），prototype默认指向自身的构造函数，将对象A的prototype等于对象B的constructor，则对象A继承于B，形成原型链。如果查找A的属性或对象，则不断向上寻找，直到object对象。其中有isPrototypeOf()方法用来检验一个对象是否属于原型链中，hasPrototypeOf()方法用来检验对象是否属于本地，即不是继承于原型链。</p>
	</div>
	<div class="item">
		<em>闭包</em>
		<pre>
	闭包指有权访问另一个函数作用域中的变量的函数。
	当函数被调用时会创建一个执行环境和相应的作用域链[[scope]]，作用域链本质上是一个指向变量对象的指针列表，活动对象有层次性。
	闭包会使另一个函数的活动对象添加到它的作用域链中，当外部函数返回后，其执行环境的作用域链被销毁，
	但其活动对象依然被保存在内存中。
	直到匿名函数被销毁，闭包包含的对象才会被销毁，即将其设置为null。
	闭包的好处是可以延长作用域链，访问本应该被释放的资源。
	由于闭包会携带包含他的函数的作用域，因此会占用更多的内存，慎重使用闭包。
		</pre>
	</div>
	<div class="item">
		<em>setTimeout（）的作用域链</em>
		<p>在使用定时器时会将作用域链抛往window对象，所以执行的函数和属性为window下的对象。解决方案为使用that=this，并使用that.prototype；或者with（）添加作用域；或者使用call（）或apply（）方法添加作用域。caller返回当前对象的调用对象，callee返回当前函数对象。</p>
	</div>
	<div class="item">
		<em>事件处理程序</em>
		<p>DOM2级事件规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。DOM2规定捕获阶段不涉及事件目标，但高版本浏览器都会在捕获阶段触发事件，所以有两次机会操作事件。其中有addEventListener()和removeEventListener(),都接受三个参数：事件名、事件处理程序、布尔值（true表示捕获阶段处理，false是冒泡阶段，一般为了兼容性，均设为false）。添加的事件只能通过这个移除，匿名函数无法移除。IE版为attachEvent()和detachEvent().</p>
	</div>
	<div class="item">
		<em>模块化编程</em>
		<pre>
var Person = (function () { 
var name='叶小钗';
var getName: function () {};
var setName: function () {};
return {get: getName, set: setName};
})();
创建实例，返回调用方法，保证内部属性和方法的封装性（利用作用域）。
		</pre>
	</div>
	<div class="item">
		<em>this指针</em>
		<pre>
	javascript中的this永远指向其函数拥有者”或者“this指针代表的是执行当前代码的对象的所有者”
	1 方法调用模式：作为对象属性调用obj.func()
	2 函数调用模式：指向全局，直接调用 func()
	3 构造器调用模式：new方式调用，会隐式创建一个新对象其隐藏链接至函数prototype成员
	4 call/apply调用模式：动态改变this指向的怪咖

	函数代码中this值的最主要的特性就是：它并非静态的绑定在函数上。this的值是在进入执行上下文（Excution context）的阶段确定的。
	然而，一旦进入执行代码阶段，其值就不能改变了。如果要想给this赋一个新的值是不可能的，因为在那时this根本就不是变量了。

	“ 函数上下文中this的值是函数调用者提供并且由当前调用表达式的形式而定的。如果在调用括号()的左边有引用类型的值，
	那么this的值就会设置为该引用类型值的base对象。 所有其他情况下（非引用类型），this的值总是null。
	然而，由于null对于this来说没有任何意义，因此会隐式转换为全局对象。”

	在DOM树上添加事件，如果是元素对象（如onclick）则this指向window；如果是DOM树添加或者事件添加则为正确this指向。
	在IE中，添加事件的匿名函数会将this绑定到window，所以使用时应当传入event事件，调用event.srcElement获取事件目标。
		</pre>
	</div>
	<div class="item">
		<em>IE8及以下不支持HTML5元素的js解决方法</em>
		<p>在body文件上添加script文件，使用document.createElement('header')方法即可使IE支持HTML5元素。</p>
	</div>
	<div class="item">
		<em>函数绑定</em>
		<pre>
	在js与DOM操作时经常用到函数绑定，绑定到事件触发程序上，通常与回调函数和事件处理程序一起使用，以便保留执行环境。
	1、通过闭包完成执行环境的调用
		onclick=function(){
                handler.handlerFun();
        }
    2、可以自定义bind（）函数将函数绑定到指定环境中运行
    	function bind(fn,context){
            return function(){
                return fn.apply(context,arguments);
            };
        }
        此处arguments是内部匿名函数的。
		</pre>
	</div>
	<div class="item">
		<em>window对象</em>
		<pre><xml>
Window 对象是 JavaScript 层级中的顶层对象。
Window 对象代表一个浏览器窗口或一个框架。
Window 对象会在 <body> 或 <frameset> 每次出现时被自动创建。

open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。
window.open(URL,name,features,replace)</xml>
<table class="tableCSS">
<thead>
	<tr>
		<td>参数</td>
		<td>描述</td>
	</tr>
</thead>
<tbody>
	<tr>
		<td>URL</td>
		<td>一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。</td>
	</tr>
	<tr>
		<td>name</td>
		<td>一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 <xmp><a> 和 <form> </xmp>的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。</td>
	</tr>
	<tr>
		<td>features</td>
		<td>一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。</td>
	</tr>
	<tr>
		<td>replace</td>
		<td>一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：

true - URL 替换浏览历史中的当前条目。
false - URL 在浏览历史中创建新的条目。</td>
	</tr>
</tbody>
	
</table>
		</pre>
	</div>
	<div class="item">
		<em>未完</em>
		<pre>
12、对JS中函数绑定的理解？函数绑定可以使用哪两个函数？
13、jQuery的特点？
14、简述Ajax的异步机制。Ajax有哪些好处和弊端？		
		</pre>
	</div>
	<div class="item">
		<em>零碎知识点</em>
		<pre>
	所有变量申明都会在范围作用域的顶部。
	函数声明也是提前的，所有的函数声明都在执行代码之前都已经完成了声明。
		</pre>
	</div>
	<div class="item">
		<em>未完</em>
		<pre>
12、对JS中函数绑定的理解？函数绑定可以使用哪两个函数？
13、jQuery的特点？
14、简述Ajax的异步机制。Ajax有哪些好处和弊端？		
		</pre>
	</div>
</body>
</html>