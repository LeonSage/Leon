<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
	<meta http-equiv="Content-Type" content="text/html" charset="utf-8" />
	<title>CORS</title>
	<meta name="author" content="Leon" />
	<meta name="description" content="The page describes the usage of Cross-Origin Resource Sharing in js." />
	<link rel="stylesheet" type="text/css" href="../../js/bootstrap/css/bootstrap.min.css">
	<style type="text/css">
		body,xmp{padding: 0px;margin: 0px;}
		.panel-body{font-size: 15px;}
		.panel-body dt{width: 200px;text-align: right;margin-right: 20px;}
		.title{color: rgba(50,160,180,1);font-size: 16px;}
		span[title]{font-size: 18px;margin-bottom: 5px;display:inline-block;line-height: 20px;}
		pre{overflow-x:hidden; }
		tr{text-align: center;}
		section{margin-bottom: 20px;}
		section:after{content: "------------------------------------------------------------------------------";color: lightblue;}
		#rect-drawing,#rotate-clock-drawing,#text-clock-drawing,#clock-drawing{border:1px solid gray;width: 500px;}
		.dt-lg-350 dt{width: 350px;}
		textarea{width: 80%;min-height: 300px;}
	</style>
</head>
<body>
	<ol class="breadcrumb">
		<li><a href="#">JS</a></li>
		<li><a href="#">CORS</a></li>
		<li class="active">跨源资源共享</li>
	</ol>
	<h1><strong>CORS</strong></h1>
	<div class="panel panel-info">
		<div class="panel-heading">说明:</div>
		<div class="panel-body">
			<ul>
				<li>通过XHR实现AJAX通信的一个主要限制,来源于跨域安全策略.默认情况下,XHR对象只能访问与包含它的页面位于同一个域的资源.这种安全策略可以预防某些恶意行为,但是,实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的.</li>
				<li>CORS(Cross-Origin Resource Sharing,跨源资源共享)是W3C的一个工作草案,定义了在必须访问跨域资源时,浏览器与服务器应该如何沟通.CORS背后的基本思想,就是使用自定义的HTTP头部让浏览器与服务器进行沟通,从而决定请求或响应是否成功.</li>
				<li>比如一个简单的使用GET或POST发送的请求,他没有自定义的头部,而主题内容是text/plain.在发送该请求时,需要给它附加一个额外的Origin头部,其中包含请求页面的源信息(协议,域名和端口),以便服务器根据这个头部信息来决定是否给予响应.
				<pre>Origin头部的一个示例:  Origin:http://www.nczonline.net</pre></li>
				<li>如果服务器认为这个请求可以接受,就在Access-Control-Allow0Origin头部中回发相同的源信息(如果是公共资源,可以回发"*").
				<pre>Access-Control-Allow-Origin:http:www.nczonline.net</pre></li>
				<li>如果没有这个头部,或者有这个头部但源信息不匹配,浏览器就会驳回请求.正常情况下,浏览器会处理请求.注意:请求和响应都不包含cookie信息</li>
			</ul>
		</div>
		<div class="panel-footer">
			关于本章节CORS内容,主要参考于书籍<strong>&lt;&lt;JavaScript 高级程序设计(第3版)&gt;&gt;</strong>.
		</div>
	</div>
	<div class="panel panel-info">
		<div class="panel-heading">
			学会实现CORS
		</div>
		<div class="panel-body">
			<section>
				<span class="label label-info" title>IE对CORS的实现</span>
				<p>要使用&lt;canvas&gt;元素,必须先设置其width和height属性,指定可以绘图的区域大小.出现在开始和结束标签中的内容是后备信息,如果浏览器不支持&lt;canvas&gt;元素,就会显示这些信息.</p>
				
				<pre>&lt;canvas id="drawing" width="200" height="200"&gt;A drawing of something.&lt;/canvas&gt;</pre>
				<p class="help-block">也可以通过CSS为该元素添加样式,如果不添加任何样式或者不绘制任何图形,在页面中是看不到该元素的.</p>
			</section>

			<section>
				<span class="label label-info" title>其他浏览器对CORS的实现</span>
				<p>要在这个画布上(canvas)上绘图,需要取得绘图上下文.而去的绘图上下文对象的引用,需要调用getContext()方法并传入上下文的名字.传入"2d",就可以取得2D上下文对象.</p>
				<pre>
var drawing=document.getElementById("drawing");
//确定浏览器支持&lt;cnavas&gt;元素
if(drawing.getContext){
	var context=drawing.getContext("2d");
	//更多代码
}
				</pre>
			</section>

			<section>
				<span class="label label-info" title>Preflighted Requests</span>
				<p>使用toDataURL()方法,可以导出在&lt;canvas&gt;元素上绘制的图像.这个方法接受一个参数,即图像的MIME类型格式,而且适合于创建图像的任何上下文.</p>
				<pre>
//取得一幅PNG格式的图像
var drawing=document.getElementById("drawing");
if(drawing.getContext){
	//取得图像的数据URI
	var imgURI= drawing.toDataURL("image/png");
	image.src=imgURI;
	document.body.appendChild(image);
}
				</pre>
				<p class="help-block">默认情况下,浏览器会将图片编码为PNG格式.<br />如果绘制到画布上的图像来自不同的域,toDataURL()方法会抛出错误.</p>
			</section>

			<section>
				<span class="label label-info" title>带凭据的请求</span>
				<p>使用2D绘图上下文提供的方法,可以绘制简单的2D图形,比如矩形,弧线和路径.2D上下文的坐标开始于&lt;canvas&gt;元素的左上角,原点坐标为(0,0).</p>
				<p>2D上下文的两种基本绘图操作是填充和描边.填充,就是用指定的样式(颜色,渐变或图像)填充图形;描边,就是只在图形的边缘画线.大多数2D上下文操作都会细分为填充和描边两个操作,而操作的结果取决于两个属性:fillStyle和strokeStyle.</p>
				<p>这两个属性的值可以是字符串,渐变对象或模式对象,而且默认值均为"#000".指定颜色可以为任何格式,如颜色名,十六进制码,rgb,rgba或hsla.</p>
				<pre>
//设置描边样式和填充样式
var drawing=document.getElementById("drawing");
if(drawing.getContext){
	var context=drawing.getContext("2d");
	context.strokeStyle="red";
	context.fillStyle="#0000ff";
}
				</pre>
				<p class="help-block">所有涉及描边和填充的操作都将使用这两个样式,直至重新设置这两个值.<br />这两个属性的值也可以是渐变对象或模式对象.</p>
			</section>

			<section>
				<span class="label label-info" title>跨浏览器的CORS</span>
				<p>矩形是唯一一种可以在2D上下文中直接绘制的形状.</p>
				<p>与矩形有关的方法包括fillRect(),strokeRect()和clearRect().这3个方法都能接受4个参数:矩形的x坐标,y坐标,宽度和高度,单位均为px.</p>
				<p>这两个属性的值可以是字符串,渐变对象或模式对象,而且默认值均为"#000".指定颜色可以为任何格式,如颜色名,十六进制码,rgb,rgba或hsla.</p>
				<p>描边线条的宽度由lineWidth属性控制,该属性可以是任意整数.</p>
				<p>lineCap属性可以控制线条末端的形状是平头("butt"),圆头("round")和方头("square").</p>
				<p>lineJoin属性可以控制线条相交的方式是圆交("round"),斜交("bevel")还是斜接("miter").</p>
				<p>clearRect()方法用于清楚画布上的矩形区域,本质上是通过上下文把某一区域变透明.</p>
				<pre>
//绘制矩形
var drawing=document.getElementById("rect-drawing");
if(drawing.getContext){
	var context=rectDrawing.getContext('2d');
	//绘制红色矩形
	context.fillStyle="#ff0000";
	context.fillRect(10,10,50,50);
	//绘制蓝色矩形
	context.fillStyle="rgba(0,0,255,0.5)";
}else{
	alert("本浏览器不支持Canvas绘图.")
}
				</pre>
				<canvas id="rect-drawing">The rect-drawing.</canvas>
				<p class="help-block"></p>
			</section>

			<section>
				<span class="label label-info" title>图像Ping</span>
				<p>要绘制路径,首先必须调用beginPath()方法,表示要开始绘制新路径.然后再通过下列方法来实际的绘制路径:</p>
				<dl class="dl-horizontal dt-lg-350">

					<dt><abbr title="arc(x,y,radius,startAngle,endAngle,counterclockwise)"><code>arc(x,y,radius,startAngle,endAngle,counterclockwise)</code></abbr> : </dt>
					<dd><pre>以(x,y)为圆心绘制一条弧线,弧线半径为radius,起始和结束角度(用弧度表示)分别为startAngle和endAngle.最后一个参数表示是否逆时针,false为顺时针方向计算.</pre></dd>

					<dt><code>arcTo(x1,y1,x2,y2,radius)</code> : </dt>
					<dd><pre>从上一点开始绘制一条弧线,到(x2,y2)为止,并且以给定的半径radius穿过(x1,y1).</pre></dd>

					<dt><code>bezierCurveTo(c1x,c1y,c2x,c2y,x,y)</code> : </dt>
					<dd><pre>从上一点开始绘制一条曲线,到(x,y)为止,并且以(c1x,c1y)和(c2x,c2y)为控制点.</pre></dd>

					<dt><code>lineTo(x,y)</code> : </dt>
					<dd><pre>从上一点开始绘制一条直线,到(x,y)为止.</pre></dd>

					<dt><code>moveTo(x,y)</code> : </dt>
					<dd><pre>将绘图游标移动到(x,y),不画线.</pre></dd>

					<dt><code>quadraticCurveTo(cx,cy,x,y)</code> : </dt>
					<dd><pre>从上一点开始绘制二次曲线,到(x,y)为止,并且以(cx,cy)作为控制点.</pre></dd>

					<dt><code>rect(x,y,width,height)</code> : </dt>
					<dd><pre>从点(x,y)开始绘制一个宽度为width和高度为height的矩形.这个方法绘制的是矩形路径,不是strokeRect()和fillRect()绘制的独立的形状.</pre></dd>

				</dl>
				
				<p>创建路径后,如果想绘制一条连接到路径起点的线条,可以调用closePath().</p>
				<p>如果路径已经完成,可以调用fill()方法用fillStyle填充它.</p>
				<p>还可以调用stroke()方法对路径描边,使用的是strokeStyle.</p>
				<p>最后可以使用clip()方法,在路径上创建一个剪切区域.</p>
				<p>在2D绘图上下文中中,路径是一种主要的绘图方式,因为路径能为要绘制的图形提供更多控制,可以使用isPointInPath(x,y)的方法来确定画布上的(x,y)一点是否在路径上.</p>
				<pre>
//绘制一个概念时钟表盘
var clockDrawing=document.getElementById('clock-drawing');
if(clockDrawing.getContext){
	var context=clockDrawing.getContext('2d');
	//开始绘制路径
	context.beginPath();
	//绘制外圆
}else{
	alert("本浏览器不支持Canvas绘图.")
}
				</pre>
				<canvas id="clock-drawing">The clock-drawing.</canvas>
				<p class="help-block"><br /></p>
			</section>

			<section>
				<span class="label label-info" title>JSONP</span>
				<p>JSONP是JSON with padding(填充式JSON或参数式JSON)的简写,是应用JSON的一种新方法.JSONP看起来与JSON差不多,只不过是被包含在函数调用中的JSON.
				<pre>callback({"name":"Nicholas"});</pre></p>
				<p>JSONP由两部分组成:回调函数和数据.回调函数是当响应到来时应该在页面中调用的函数.回调函数的名字一般是在请求中指定的.而数据就是传入回调函数中的JSON数据.
				<pre>一个典型的JSONP请求:  http://freegeoip.net/json/?callback=handleResonse</pre></p>				
				<p>这个URL是在请求一个JSONP地理定位服务.通过查询字符串来指定JSONP服务的回调函数,这里的回调函数名字为handleResponse().</p>
				<p>JSONP是通过&lt;script&gt;元素来使用的,使用时可以为src属性制定一个跨域URL.这里的&lt;script&gt;与&lt;img&gt;元素类似,都有能力不受限制地从其他域加载资源.因为JSONP是有效的JavaScript代码,所以请求完成后,即在JSONP响应加载到页面中以后,就会立即执行.</p>
				<p>JSONP非常简单易用.与图像Ping相比,他的优点在于能够直接访问响应文本,支持在浏览器与服务器之间双向通信.不过,JSONP也有两点不足:</p>
				<p>首先,JSONP是从其他域中加载代码执行.如果其他域不安全,很可能会在响应中夹带一些恶意代码,而此时除了完全放弃JSONP调用之外,没有其他办法追究.因此不是你自己运维的Web服务时,一定得保证它安全可靠.</p>
				<p>其次,要确定JSONP请求是否失败并不容易.虽然HTML5给&lt;script&gt;元素新增了一个onerror事件处理程序,但目前还没有得到任何浏览器支持.为此,开发人员不得不使用计时器检测在指定时间内是否接到了响应.</p>
				<pre>
//通过查询地理定位服务来显示你的IP地址和位置信息
function handleResponse(response){
	alert("You`re at IP address "+response.ip+" ,which is in "+response.city+" , "+response.region_name);
}
var script=document.createElement("script");
script.src="http://freegeoip.net/json/?callback=handleResponse";
document.body.insertBefore(script,document.body.firstChild);
				</pre>
				<p class="alert alert-info">JSONP具体解决跨域问题:</p>
				<p>先在本地使用NodeJs建立两个本地服务器,分别监听:1337和:1338端口,根据同源策略,浏览器不能发起请求.</p>
				<pre>
//以client为例,省略了部分代码,留下了主体实现.
//server类似,只是变成了.listen(1337,'127.0.0.1');

//引入内置模块,分别负责http的创建,地址的切分,路径的组合,文件系统的读取
var http=require('http')
	,url=require('url')
	,path=require('path')
	,fs=require('fs');
function client(handles){
	//创建监听127.0.0.1(即本地地址,相当于localhost://)的:1337端口的服务端程序
	http.createServer(function (request,response){
		//将url转换为对象并获取其中的pathname
		var pathname=url.parse(request.url).pathname;
		//如果pathname存在处理程序,则由处理程序完成(此处省略了处理程序--返回请求的网页)
		if(typeof(handles[pathname])==="function"){
			return handles[pathname](response,request);
		}
		//将目录名和路径名进行组合形成请求的文件路径
		var filename=path.join(__dirname,'..',pathname);
		//使用文件系统中的函数确定文件路径是否存在请求文件
		fs.exists(filename,function(exists){
			//如果不存在,则返回404 Not Found并写下日志文件
			if(!exists){
				console.error("Request for "+filename+" : 404 Not Found.");
				/*response.setHeader('Content-Type','text/plain;charset=utf-8');*/
				response.writeHead(404,{"Content-Type":"text/plain"});
				response.write("404 Not Found");
				response.end();
				return;
			}else{
				//如果存在,则读取文件
				fs.readFile(filename,'binary',function(err,file){
					//在读取过程中,发生服务器内部错误,则返回500 Server Error并写下日志
					if(err){
						console.error("Request for "+filename+" : 500 "+err);
						response.writeHead(500,{"Content-Type":"text/plain"});
						response.write(err);
						response.end();
						return;
					}
					var contentType="none";
					//查看文件名的后缀对设置对应的响应格式
					var ext=path.extname(filename);
					switch(ext){
						case ".html": contentType="text/html";break;
						case ".js": contentType="text/javascript";break;
						case ".css": contentType="text/css";break;
					}
					//处理成功,返回200 OK并写下日志
					//response.setHeader('Content-Type','text/html;charset=utf-8');
					response.writeHead(200,{"Content-Type":contentType});
					response.write(file,"binary");
					response.end();
					console.log("Request for "+filename+" : 200 OK.");
				})
			}			
		});
	}).listen(1338,'127.0.0.1');
	//服务器启动,并输出服务器路径
	console.log('Server running at http://127.0.0.1:1338/');
}</pre>
				<p>在其中一个端口开启的页面上设置一个按钮并请求不同端口上的资源.</p>
				<pre>
//jQuery操作AJAX请求不同端口下的someJson.txt文件
var $.get($("src="http://localhost:1337/someJson.txt",function(data){
	console.log(data);
});</pre>
				<p>但根据同源策略,很明显浏览器不能发起请求,会返回<code>not allowed by Access-Control-Allow-Origin</code></p>
				<p>浏览器对script不存在同源策略,所以我们可以使用CDN来请求不同的库.</p>
				<pre>&lt;script src="http://localhost:1337/../js/bootstrap/js/bootstrap.min.js"&gt;&lt;//script&gt;	//请求不同源的js不会发生错误</pre>
				<p>所以我们可以通过script来获取不同源的json,并赋予一个回调函数来返回需要的内容.</p>
				<pre>
//HTML页面中的按钮
&lt;button class="btn btn-primary btn-lg jsonp"&gt;请求:1337&lt;/button&gt;

$('.jsonp').on('click',function(){
	var $jsonp=$('&lt;script src="http://localhost:1337/someJson.txt?callback=jsonpcallback"&gt;&lt;//script&gt;');
		$jsonp.appendTo('body');
});</pre>
				<p>在someJson.txt的内容为:</p>
				<pre>
//定义一个方法返回json格式的内容
function jsonpcallback(json){
	console.log(json);
	//序列化输出json
	alert(JSON.stringify(json));
}

//执行回调函数,参数为要返回的内容
jsonpcallback({"Email":"moyanxidian@foxmail.com","Remark":"Shannxi"})</pre>
				<p>服务器会返回200 OK,并输出<code>Object {"Email":"moyanxidian@foxmail.com","Remark":"Shannxi"}</code></p>
				<p>可以利用jQuery的AJAX来更为方便的实现:</p>
				<pre>
$.ajax({
	url:"http://localhost:1337/someJson.txt",
	dataType:"jsonp",
	jsonp:"callback",
	success:function(data){
		console.log(data);
	}
})</pre>
				<p>结果输出和上述一样.</p>
				<p class="help-block"></p>
			</section>

			<section>
				<span class="label label-info" title>Comet</span>
				<p>2D绘制上下文支持各种基本的绘制变换.通过绘制上下文时,会以默认值初始化变换矩阵,在默认的变换矩阵下,所有处理都按描述直接绘制,为绘制上下文应用变换,会导致使用不同的变换矩阵应用处理,从而产生不同的结果.</p>
				<p>可以通过如下方法修改变换矩阵:</p>
				<dl class="dl-horizontal dt-lg-350">

					<dt><code>rotate(angle)</code> : </dt>
					<dd><pre>围绕原点旋转图像angle弧度.</pre></dd>

					<dt><code>scale(scaleX,scaleY)</code> : </dt>
					<dd><pre>缩放图像,在x方向乘以scaleX,在y方向乘以scaleY.默认值为1.0.</pre></dd>

					<dt><code>translate(x,y)</code> : </dt>
					<dd><pre>将坐标原点移动到(x,y).执行这个变换后,坐标(0,0)会变成之前有(x,y)表示的点.</pre></dd>

					<dt><code>transform(m1_1,m1_2,m2_1,m2_2,dx,dy)</code> : </dt>
					<dd><pre>直接修改变换矩阵,方式是乘以如下矩阵.
| m1_1  m1_2  dx |
| m2_1  m2_2  dy |
|   0     0    1 |
  					</pre></dd>

					<dt><code>setTransform(m1_1,m1_2,m2_1,m2_2,dx,dy)</code> : </dt>
					<dd><pre>将变换矩阵重置为默认状态,然后再调用transform().</pre></dd>

				</dl>
				
				<p>在上下文中执行的变换将会一直有效直到被再次修改.</p>
				<p>虽然没有办法将一切设置重置为默认值,但可以使用save()和restore()方法来完成某组属性和变换的组合.当save()后,当前的所有设置都会进入一个栈的结构,得以妥善保管.当restore()后,栈结构回退一级,恢复之前状态,可以多次调用.</p>
				<p>save()方法保存的只是对绘图上下文的设置和变换,不会保存绘图上下文的内容.</p>
				<pre>
var rotateClockDrawing=document.getElementById('rotate-clock-drawing');
if(rotateClockDrawing.getContext){
	var context=rotateClockDrawing.getContext('2d');
	context.beginPath();
	context.arc(70,70,69,0,2*Math.PI,false);
	context.moveTo(135,70);
	context.arc(70,70,65,0,2*Math.PI,false);
	context.font="bold 14px";
	context.textAlign="center";
	context.textBaseline="middle";
	context.fillText("12",70,15);
	context.fillText("3",125,70);
	context.fillText("6",70,125);
	context.fillText("9",15,70);
	//变换原点位置到表盘中心
	context.translate(70,70);
	//旋转表针45°
	context.rotate(1);
	//画出新的路径时,需移动到原点
	context.moveTo(0,0);
	//绘制分针
	context.lineTo(0,-55);
	context.moveTo(0,0);
	//绘制时针
	context.lineTo(-40,0);			
	context.stroke();
}else{
	alert("本浏览器不支持Canvas绘图.")
}
				</pre>
				<canvas id="rotate-clock-drawing">The rotate-clock-drawing.</canvas>
				<p class="help-block"></p>
			</section>
		</div>
	</div>
<script src="../../js/jQuery/jquery-1.11.3.min.js"></script>
<script src="../../js/bootstrap/js/bootstrap.min.js"></script>
<script>
	$(function(){
		var $run=$('.runBtn');
		var $bar=$('#bar');
		var $copy=$('.copyBtn');
		var $textarea=$('textarea');
		$('body').scrollTop(5500);

		//CORS
		/*function handleResponse(response){
			alert("You`re at IP address "+response.ip+" ,which is in "+response.city+" , "+response.region_name);
		}
		var script=document.createElement("script");
		script.src="CORS.html/?callback=handleResponse";
		document.body.insertBefore(script,document.body.firstChild);*/
		//alert("You`re at IP address "+response.ip+" ,which is in "+response.city+" , "+response.region_name);

		$run.on('click',function(){
			//使展示板上生成文本框内的HTML代码
			$bar.html($textarea.val());
			//滑动展示板到视口
			//当检测到scrollTop为body下元素时(非IE内核)
			if(document.body.scrollTop){
				$("body").animate({scrollTop:$('#bar').offset().top});
			}else if(document.documentElement.scrollTop){
				//当检测到scrollTop为documentElement下元素时(IE内核)
				document.documentElement.scrollTop=$('#bar').offset().top;
			}			
		});
		$copy.on('click',function(){
			$textarea.select();			
			//alert("Done?"+$textarea.val().substring($textarea.selectionStart,$textarea.selectionEnd));
			//只有IE内核支持浏览器命令execCommand("copy");
			document.execCommand("Copy");
			//检测浏览器,当存在MSIE关键字且当前不是Opera浏览器时,则为IE浏览器
			if(navigator.userAgent.indexOf("MSIE")>-1&&navigator.userAgent.indexOf("Opera")<0){
				alert("已复制到粘贴板.");
			}else{
				alert("抱歉,该复制功能当前只能在IE浏览器下使用.");
			}
		});
	});
</script>
</body>
</html>
